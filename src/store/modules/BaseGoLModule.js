// import makeValidatorForRange from '../../helpers';
//
// const vectorsToCheck = [[-1, -1], [-1, 0], [-1, 1],
//     [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];

/**
 * Generate arrays with content generated by gen function.
 */
// function makeArray(len, gen) {
//     return Array.from(new Array(len), gen);
// }

/**
 * Generate arrays with random content.
 */
// function randomPixels(width, height) {
//     return makeArray(height, () => (
//         makeArray(width, () => randomPixel())
//     ));
// }

/**
 * Basic logic function saying if pixel should be turned on or off.
 */
// function turnOnOrOff(i, j, oldPixels, height, width) {
//     let aliveNeighbours = 0;
//
//     const validXCoordinate = makeValidatorForRange(0, width - 1);
//     const validYCoordinate = makeValidatorForRange(0, height - 1);
//
//     const validCoordinates = ([x, y]) => (
//         validXCoordinate(x) && validYCoordinate(y)
//     );
//
//     // vector way
//
//     aliveNeighbours = vectorsToCheck
//         // translate to point [j, i]
//         .map(([x, y]) => ([x + j, y + i]))
//         // filter out points out of bounds
//         .filter(validCoordinates)
//         // sum alive neighbours
//         .reduce(
//             (value, [x, y]) => (value + oldPixels[y][x]),
//             0,
//         );
//
//     if (aliveNeighbours === 3) {
//         return 1;
//     }
//     if (aliveNeighbours === 2 && oldPixels[i][j] === 1) {
//         return 1;
//     }
//
//     return 0;
// }

/**
 * Function to apply turnOnOrOff on every pixel, to transform old pixels
 * into newer version, in one time step.
 */
// function evolve(pixels) {
//     const oldPixels = pixels;
//
//     const height = oldPixels.length;
//     const width = oldPixels[0].length;
//
//     const newPixels = oldPixels.map(
//         (row, i) => row.map(
//             (pixel, j) => turnOnOrOff(i, j, oldPixels, height, width),
//         ),
//     );
//
//     return newPixels;
// }

// function randomPixel() {
//     return Math.round(Math.random());
// }

const state = (randomPixelsFunction) => ({
    pixels: randomPixelsFunction(100, 100),
    interval: null,
    lastI: null,
    lastJ: null,
});

const mutations = (evolveFunction, randomPixelFunction) => ({
    stepForward(s) {
        s.pixels = evolveFunction(s.pixels);
    },

    setInterval(s, interval) {
        s.interval = interval;
    },

    addCell(s, { i, j }) {
        if (i !== s.lastI || j !== s.lastJ) {
            if (s.pixels[i]) {
                s.pixels[i].splice(j, 1, randomPixelFunction());
            }

            s.lastI = i;
            s.lastJ = j;
        }
    },
});

const actions = {
    stepForward({ commit }) {
        commit('stepForward');
    },

    start({ commit, state: s, dispatch }) {
        if (!s.interval) {
            commit('setInterval', setInterval(() => dispatch('stepForward', 100)));
        }
    },

    stop({ commit, state: s }) {
        if (s.interval) {
            clearInterval(s.interval);
            commit('setInterval', null);
        }
    },

    toggleStart({ state: s, dispatch }) {
        if (s.interval) {
            dispatch('stop');
        } else {
            dispatch('start');
        }
    },
};

export default (
    evolveFunction,
    randomPixelFunction,
    randomPixelsFunction,
) => ({
    namespaced: true,

    state: state(randomPixelsFunction),
    mutations: mutations(evolveFunction, randomPixelFunction),
    actions,
});
